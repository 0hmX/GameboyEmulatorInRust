use super::{Cpu, CpuResult};
use crate::memory_bus::MemoryBus;

// --- LD Implementations ---
impl Cpu {
    // LD rr, d16
    pub fn op_ld_bc_d16(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.set_bc(self.read_d16(bus));
        Ok(0)
    }
    pub fn op_ld_de_d16(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.set_de(self.read_d16(bus));
        Ok(0)
    }
    pub fn op_ld_hl_d16(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.set_hl(self.read_d16(bus));
        Ok(0)
    }
    pub fn op_ld_sp_d16(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.sp = self.read_d16(bus);
        Ok(0)
    }

    // LD (rr), A
    pub fn op_ld_bc_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        bus.write_byte(self.get_bc(), self.a);
        Ok(0)
    }
    pub fn op_ld_de_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        bus.write_byte(self.get_de(), self.a);
        Ok(0)
    }
    // LD (HL+/-), A
    pub fn op_ld_hli_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.get_hl();
        bus.write_byte(addr, self.a);
        self.set_hl(addr.wrapping_add(1));
        Ok(0)
    }
    pub fn op_ld_hld_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.get_hl();
        bus.write_byte(addr, self.a);
        self.set_hl(addr.wrapping_sub(1));
        Ok(0)
    }

    // LD r, d8
    pub fn op_ld_b_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.b = self.read_d8(bus);
        Ok(0)
    }
    pub fn op_ld_c_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.c = self.read_d8(bus);
        Ok(0)
    }
    pub fn op_ld_d_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.d = self.read_d8(bus);
        Ok(0)
    }
    pub fn op_ld_e_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.e = self.read_d8(bus);
        Ok(0)
    }
    pub fn op_ld_h_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.h = self.read_d8(bus);
        Ok(0)
    }
    pub fn op_ld_l_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.l = self.read_d8(bus);
        Ok(0)
    }
    pub fn op_ld_a_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.a = self.read_d8(bus);
        Ok(0)
    }

    // LD (HL), d8
    pub fn op_ld_hlp_d8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let value = self.read_d8(bus);
        bus.write_byte(self.get_hl(), value);
        Ok(0)
    }

    // LD (a16), SP
    pub fn op_ld_a16_sp(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.read_d16(bus);
        bus.write_byte(addr, (self.sp & 0xFF) as u8);
        bus.write_byte(addr.wrapping_add(1), (self.sp >> 8) as u8);
        Ok(0)
    }

    // LD A, (rr)
    pub fn op_ld_a_bc(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.a = bus.read_byte(self.get_bc());
        Ok(0)
    }
    pub fn op_ld_a_de(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.a = bus.read_byte(self.get_de());
        Ok(0)
    }
    // LD A, (HL+/-)
    pub fn op_ld_a_hli(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.get_hl();
        self.a = bus.read_byte(addr);
        self.set_hl(addr.wrapping_add(1));
        Ok(0)
    }
    pub fn op_ld_a_hld(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.get_hl();
        self.a = bus.read_byte(addr);
        self.set_hl(addr.wrapping_sub(1));
        Ok(0)
    }

    // LD r, r' (Generated by macro)
    ld_r_r!(op_ld_b_b, b, b);
    ld_r_r!(op_ld_b_c, b, c);
    ld_r_r!(op_ld_b_d, b, d);
    ld_r_r!(op_ld_b_e, b, e);
    ld_r_r!(op_ld_b_h, b, h);
    ld_r_r!(op_ld_b_l, b, l);
    ld_r_r!(op_ld_b_a, b, a);
    ld_r_r!(op_ld_c_b, c, b);
    ld_r_r!(op_ld_c_c, c, c);
    ld_r_r!(op_ld_c_d, c, d);
    ld_r_r!(op_ld_c_e, c, e);
    ld_r_r!(op_ld_c_h, c, h);
    ld_r_r!(op_ld_c_l, c, l);
    ld_r_r!(op_ld_c_a, c, a);
    ld_r_r!(op_ld_d_b, d, b);
    ld_r_r!(op_ld_d_c, d, c);
    ld_r_r!(op_ld_d_d, d, d);
    ld_r_r!(op_ld_d_e, d, e);
    ld_r_r!(op_ld_d_h, d, h);
    ld_r_r!(op_ld_d_l, d, l);
    ld_r_r!(op_ld_d_a, d, a);
    ld_r_r!(op_ld_e_b, e, b);
    ld_r_r!(op_ld_e_c, e, c);
    ld_r_r!(op_ld_e_d, e, d);
    ld_r_r!(op_ld_e_e, e, e);
    ld_r_r!(op_ld_e_h, e, h);
    ld_r_r!(op_ld_e_l, e, l);
    ld_r_r!(op_ld_e_a, e, a);
    ld_r_r!(op_ld_h_b, h, b);
    ld_r_r!(op_ld_h_c, h, c);
    ld_r_r!(op_ld_h_d, h, d);
    ld_r_r!(op_ld_h_e, h, e);
    ld_r_r!(op_ld_h_h, h, h);
    ld_r_r!(op_ld_h_l, h, l);
    ld_r_r!(op_ld_h_a, h, a);
    ld_r_r!(op_ld_l_b, l, b);
    ld_r_r!(op_ld_l_c, l, c);
    ld_r_r!(op_ld_l_d, l, d);
    ld_r_r!(op_ld_l_e, l, e);
    ld_r_r!(op_ld_l_h, l, h);
    ld_r_r!(op_ld_l_l, l, l);
    ld_r_r!(op_ld_l_a, l, a);
    ld_r_r!(op_ld_a_b, a, b);
    ld_r_r!(op_ld_a_c, a, c);
    ld_r_r!(op_ld_a_d, a, d);
    ld_r_r!(op_ld_a_e, a, e);
    ld_r_r!(op_ld_a_h, a, h);
    ld_r_r!(op_ld_a_l, a, l);
    ld_r_r!(op_ld_a_a, a, a);

    // LD r, (HL) (Generated by macro)
    ld_r_hlp!(op_ld_b_hlp, b);
    ld_r_hlp!(op_ld_c_hlp, c);
    ld_r_hlp!(op_ld_d_hlp, d);
    ld_r_hlp!(op_ld_e_hlp, e);
    ld_r_hlp!(op_ld_h_hlp, h);
    ld_r_hlp!(op_ld_l_hlp, l);
    ld_r_hlp!(op_ld_a_hlp, a);

    // LD (HL), r (Generated by macro)
    ld_hlp_r!(op_ld_hlp_b, b);
    ld_hlp_r!(op_ld_hlp_c, c);
    ld_hlp_r!(op_ld_hlp_d, d);
    ld_hlp_r!(op_ld_hlp_e, e);
    ld_hlp_r!(op_ld_hlp_h, h);
    ld_hlp_r!(op_ld_hlp_l, l);
    ld_hlp_r!(op_ld_hlp_a, a);

    // LD (a16), A
    pub fn op_ld_a16_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.read_d16(bus);
        bus.write_byte(addr, self.a);
        Ok(0)
    }
    // LD A, (a16)
    pub fn op_ld_a_a16(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let addr = self.read_d16(bus);
        self.a = bus.read_byte(addr);
        Ok(0)
    }

    // LDH (a8), A --- LD (FF00+a8), A
    pub fn op_ldh_a8_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let offset = self.read_d8(bus) as u16;
        bus.write_byte(0xFF00 + offset, self.a);
        Ok(0)
    }
    // LDH A, (a8) --- LD A, (FF00+a8)
    pub fn op_ldh_a_a8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let offset = self.read_d8(bus) as u16;
        self.a = bus.read_byte(0xFF00 + offset);
        Ok(0)
    }

    // LD (C), A --- LD (FF00+C), A
    pub fn op_ld_cp_a(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        bus.write_byte(0xFF00 + self.c as u16, self.a);
        Ok(0)
    }
    // LD A, (C) --- LD A, (FF00+C)
    pub fn op_ld_a_cp(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.a = bus.read_byte(0xFF00 + self.c as u16);
        Ok(0)
    }

    // LD HL, SP+r8
    pub fn op_ld_hl_sp_r8(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let offset = self.read_r8(bus);
        let value = offset as i16 as u16; // Sign extend
        let sp = self.sp;
        let result = sp.wrapping_add(value);
        let half_carry = (sp & 0x000F) + (value & 0x000F) > 0x000F;
        let carry = (sp & 0x00FF) + (value & 0x00FF) > 0x00FF;
        self.set_hl(result);
        self.set_flag(super::constants::FLAG_Z | super::constants::FLAG_N, false);
        self.set_flag(super::constants::FLAG_H, half_carry);
        self.set_flag(super::constants::FLAG_C, carry);
        Ok(0)
    }
    // LD SP, HL
    pub fn op_ld_sp_hl(&mut self, _bus: &mut MemoryBus) -> CpuResult<u16> {
        self.sp = self.get_hl();
        Ok(0)
    }

    // PUSH qq
    pub fn op_push_bc(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.push_word(self.get_bc(), bus);
        Ok(0)
    }
    pub fn op_push_de(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.push_word(self.get_de(), bus);
        Ok(0)
    }
    pub fn op_push_hl(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.push_word(self.get_hl(), bus);
        Ok(0)
    }
    pub fn op_push_af(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        self.f &= 0xF0; // Mask lower bits before push
        self.push_word(self.get_af(), bus);
        Ok(0)
    }

    // POP qq
    pub fn op_pop_bc(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let val = self.pop_word(bus);
        self.set_bc(val);
        Ok(0)
    }
    pub fn op_pop_de(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let val = self.pop_word(bus);
        self.set_de(val);
        Ok(0)
    }
    pub fn op_pop_hl(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let val = self.pop_word(bus);
        self.set_hl(val);
        Ok(0)
    }
    pub fn op_pop_af(&mut self, bus: &mut MemoryBus) -> CpuResult<u16> {
        let val = self.pop_word(bus);
        self.set_af(val); // set_af handles masking
        Ok(0)
    }
}